// The GPLv3 License (GPLv3)

// Copyright (c) 2023 Marvin Frohwitter

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <bits/types/FILE.h>
#include <fstream>
#include <iostream>
#include <list>
#include <string>
#include <yaml-cpp/node/parse.h>
#include <yaml-cpp/yaml.h>

// The function declarations.
std::string get_color(std::string, std::list<std::string> *);
std::string split_hex_string(std::string *, std::string);
void write_to_yaml_file(std::string, std::list<std::string> *);

// The main function handels the given argument,
// as well as the loading of the external comand 'xrdb -query', that generates
// the new color hex codes.
// To write the new colors tho the given file the functioin write_to_yaml_file
// is called.
int main(int argc, char *argv[]) {
  if (argc < 2 || argc > 2) {
    std::cout << "Incorrrect argument number was given!" << std::endl;
    exit(0);
  }
  const std::string filename = argv[1];
  FILE *subprocess_in = 0;
  try {
    subprocess_in = popen("xrdb -query", "r");
  } catch (const std::exception &) {
    std::cout << "Calling xrdb -query went wrong" << std::endl;
  }

  std::list<std::string> colorlist;
  char buff[128];
  while (fgets(buff, sizeof(buff), subprocess_in)) {
    std::string inputline = fgets(buff, sizeof(buff), subprocess_in);
    colorlist.push_back(inputline);
  }

  write_to_yaml_file(filename, &colorlist);
  pclose(subprocess_in);
  return 0;
}

// The function handels the spliting of the given string, that contains the
// actual name and the hexcode. It returns the corresponding hex code.
std::string split_hex_string(std::string *color_hex,
                           std::string delimeter) {

  color_hex->erase(0, color_hex->find(delimeter) + 1);
  return color_hex->erase(color_hex->find('\n'), color_hex->length());
}

// The function handels the search of the color name and its corresponding hex
// value in the given list, that is generated by the xrdb command.
std::string get_color(std::string color_name,
                     std::list<std::string> *xr_colors) {
  for (auto colors : *xr_colors) {
    if (colors.find(color_name) != std::string::npos) {
      return split_hex_string(&colors, "\t");
    }
  }
  return "";
}

// The function manges the Node that will be written to the given filename. It
// calls the get_color function for each color Node that is found in the given
// file. Than the Node will be written to the given file.
void write_to_yaml_file(std::string filename,
                        std::list<std::string> *provided_quarry_list) {
  YAML::Node config = YAML::LoadFile(filename);

  config["colors"]["primary"]["background"] = get_color("background", provided_quarry_list);
  config["colors"]["primary"]["foreground"] = get_color("foreground", provided_quarry_list);

  config["colors"]["normal"]["black"]       = get_color("color0", provided_quarry_list);
  config["colors"]["normal"]["red"]         = get_color("color1", provided_quarry_list);
  config["colors"]["normal"]["green"]       = get_color("color2", provided_quarry_list);
  config["colors"]["normal"]["yellow"]      = get_color("color3", provided_quarry_list);
  config["colors"]["normal"]["blue"]        = get_color("color4", provided_quarry_list);
  config["colors"]["normal"]["magenta"]     = get_color("color5", provided_quarry_list);
  config["colors"]["normal"]["cyan"]        = get_color("color6", provided_quarry_list);
  config["colors"]["normal"]["white"]       = get_color("color7", provided_quarry_list);

  config["colors"]["bright"]["black"]       = get_color("color8", provided_quarry_list);
  config["colors"]["bright"]["red"]         = get_color("color9", provided_quarry_list);
  config["colors"]["bright"]["green"]       = get_color("color10", provided_quarry_list);
  config["colors"]["bright"]["yellow"]      = get_color("color11", provided_quarry_list);
  config["colors"]["bright"]["blue"]        = get_color("color12", provided_quarry_list);
  config["colors"]["bright"]["magenta"]     = get_color("color13", provided_quarry_list);
  config["colors"]["bright"]["cyan"]        = get_color("color14", provided_quarry_list);
  config["colors"]["bright"]["white"]       = get_color("color15", provided_quarry_list);

  std::ofstream fout(filename);
  fout << config;
  fout.close();
}
